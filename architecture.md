# Mini-Paimon 架构设计

## 系统架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        应用层 (Application)                      │
│                                                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐        │
│  │  SQL Parser  │  │ Table Manager│  │ Schema Mgr   │        │
│  └──────────────┘  └──────────────┘  └──────────────┘        │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                      LSM Tree 存储引擎                           │
│                                                                 │
│  ┌────────────────────────────────────────────────────────────┐│
│  │                    读写协调层                               ││
│  │  LSMTree: put() / get() / scan() / close()                ││
│  └────────────────────────────────────────────────────────────┘│
│                              ↓                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐        │
│  │     WAL      │→ │  MemTable    │→ │  Compactor   │        │
│  │              │  │  (Active)    │  │              │        │
│  │ - append()   │  │  (Immutable) │  │ - compact()  │        │
│  │ - recover()  │  └──────────────┘  │ - merge()    │        │
│  │ - clear()    │         ↓          └──────────────┘        │
│  └──────────────┘    Flush when full        ↓                 │
│                              ↓               ↓                 │
│  ┌────────────────────────────────────────────────────────────┐│
│  │                  SSTable 文件层                             ││
│  │                                                             ││
│  │  Level 0:  [SST] [SST] [SST] [SST]  ← 4+ 个触发 compaction││
│  │  Level 1:  [SST] [SST] ... (10x)                          ││
│  │  Level 2:  [SST] [SST] ... (100x)                         ││
│  │  Level 3:  ...                                             ││
│  │  ...                                                       ││
│  │  Level 7:  [SST] ... (最大层级)                            ││
│  └────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                      文件系统层                                  │
│                                                                 │
│  warehouse/{database}/{table}/                                 │
│  ├── data/         ← SSTable 文件                              │
│  │   ├── data-0-000.sst                                       │
│  │   ├── data-0-001.sst                                       │
│  │   ├── data-1-000.sst                                       │
│  │   └── ...                                                  │
│  ├── wal/          ← WAL 日志                                  │
│  │   ├── wal-000.log                                          │
│  │   └── wal-001.log                                          │
│  ├── snapshot/     ← 快照文件                                  │
│  ├── manifest/     ← Manifest 文件                            │
│  └── schema/       ← Schema 定义                              │
└─────────────────────────────────────────────────────────────────┘
```

## 写入流程详解

```
用户调用: put(row)
    ↓
┌─────────────────────────────────────────────────────┐
│ Step 1: Write-Ahead Log (WAL)                       │
│                                                     │
│  wal.append(row)                                   │
│    ↓                                                │
│  [wal-001.log]  ← 持久化到磁盘                      │
│                                                     │
│  保证: 即使崩溃也能恢复                              │
└─────────────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────────────┐
│ Step 2: MemTable 写入                               │
│                                                     │
│  memTable.put(row)                                 │
│    ↓                                                │
│  ConcurrentSkipListMap                             │
│    [key1 → row1]                                   │
│    [key2 → row2]                                   │
│    [key3 → row3]                                   │
│                                                     │
│  内存排序: 按 RowKey 升序                           │
└─────────────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────────────┐
│ Step 3: 检查 MemTable 大小                          │
│                                                     │
│  if (size >= maxSize * 0.8) {                      │
│    触发 Flush                                       │
│  }                                                  │
└─────────────────────────────────────────────────────┘
    ↓ (如果需要 flush)
┌─────────────────────────────────────────────────────┐
│ Step 4: Flush to SSTable                           │
│                                                     │
│  1. immutableMemTable = activeMemTable             │
│  2. activeMemTable = new MemTable()                │
│  3. 写入 SSTable 文件:                              │
│     ┌────────────────────────┐                     │
│     │ Data Blocks            │                     │
│     │ Bloom Filter           │                     │
│     │ Index Block            │                     │
│     │ Footer                 │                     │
│     └────────────────────────┘                     │
│  4. 创建新 WAL                                      │
│  5. 删除旧 WAL                                      │
└─────────────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────────────┐
│ Step 5: Compaction 检查                             │
│                                                     │
│  if (needsCompaction()) {                          │
│    后台执行 compaction                              │
│  }                                                  │
└─────────────────────────────────────────────────────┘
```

## 读取流程详解

```
用户调用: get(key)
    ↓
┌─────────────────────────────────────────────────────┐
│ Step 1: Active MemTable 查询                        │
│                                                     │
│  row = activeMemTable.get(key)                     │
│  if (row != null) return row;                      │
│                                                     │
│  优势: 内存查询最快                                  │
└─────────────────────────────────────────────────────┘
    ↓ (未找到)
┌─────────────────────────────────────────────────────┐
│ Step 2: Immutable MemTable 查询                     │
│                                                     │
│  row = immutableMemTable.get(key)                  │
│  if (row != null) return row;                      │
│                                                     │
│  优势: 仍在内存中，速度快                            │
└─────────────────────────────────────────────────────┘
    ↓ (未找到)
┌─────────────────────────────────────────────────────┐
│ Step 3: SSTable 文件查询 (按层级从低到高)            │
│                                                     │
│  for each level (0 → 7):                           │
│    for each SSTable in level:                      │
│      ┌────────────────────────┐                    │
│      │ 1. 检查 min/max key   │                     │
│      │ 2. 查询 Bloom Filter  │                     │
│      │ 3. 二分查找 Index     │                     │
│      │ 4. 读取 Data Block    │                     │
│      └────────────────────────┘                    │
│      if (found) return row;                        │
│                                                     │
│  优化:                                              │
│  - Bloom Filter 快速过滤不存在的 key                │
│  - Index 减少磁盘 I/O                               │
│  - Level 0 优先 (最新数据)                          │
└─────────────────────────────────────────────────────┘
    ↓ (未找到)
┌─────────────────────────────────────────────────────┐
│ Step 4: 返回结果                                     │
│                                                     │
│  return null;  // 数据不存在                        │
└─────────────────────────────────────────────────────┘
```

## Compaction 工作流程

```
触发条件检查
    ↓
┌─────────────────────────────────────────────────────┐
│ 检查各层级是否需要 Compaction                        │
│                                                     │
│ Level 0: 文件数 >= 4 ?                              │
│   ├─ YES → 触发 Level 0 → Level 1 compaction       │
│   └─ NO  → 继续检查                                 │
│                                                     │
│ Level N (N >= 1):                                   │
│   size(Level N) / size(Level N+1) > 10 ?           │
│   ├─ YES → 触发 Level N → Level N+1 compaction     │
│   └─ NO  → 继续检查下一层                           │
└─────────────────────────────────────────────────────┘
    ↓ (需要 compaction)
┌─────────────────────────────────────────────────────┐
│ Step 1: 选择参与文件                                 │
│                                                     │
│ Level 0:                                            │
│   选择所有文件 (因为范围可能重叠)                     │
│                                                     │
│ Level N (N >= 1):                                   │
│   1. 选择当前层级文件                                │
│   2. 找出与下层重叠的文件                            │
│   3. 合并到一个集合                                  │
└─────────────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────────────┐
│ Step 2: 读取并合并数据                               │
│                                                     │
│  TreeMap<RowKey, Row> mergedData                   │
│                                                     │
│  for each inputFile:                               │
│    rows = reader.scan(inputFile)                   │
│    for each row:                                   │
│      mergedData.put(row.key, row)                  │
│                                                     │
│  特性:                                              │
│  - TreeMap 自动按 key 排序                          │
│  - 相同 key 的新值覆盖旧值                           │
└─────────────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────────────┐
│ Step 3: 写入新文件                                   │
│                                                     │
│  for each (key, row) in mergedData:                │
│    newMemTable.put(row)                            │
│    if (memTable.isFull()) {                        │
│      flush to targetLevel                          │
│      create new memTable                           │
│    }                                                │
│                                                     │
│  输出: 1个或多个新的 SSTable 文件                    │
└─────────────────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────────────────┐
│ Step 4: 更新元数据                                   │
│                                                     │
│  1. 从 sstables 列表移除输入文件                     │
│  2. 添加输出文件到 sstables 列表                     │
│  3. 删除磁盘上的旧文件                               │
│  4. 创建新 Snapshot                                 │
└─────────────────────────────────────────────────────┘
```

## 核心数据结构

### MemTable
```
ConcurrentSkipListMap<RowKey, Row>
- 并发安全的有序 Map
- 时间复杂度: O(log N)
- 自动按 key 排序
```

### SSTable Footer
```
┌────────────────────────────────┐
│ indexOffset:     long          │ ← Index 在文件中的位置
│ indexSize:       long          │ ← Index 大小
│ bloomFilterOffset: long        │ ← Bloom Filter 位置
│ bloomFilterSize:   long        │ ← Bloom Filter 大小
│ dataBlockCount:  int           │ ← 数据块数量
│ rowCount:        long          │ ← 总行数
│ minKey:          RowKey        │ ← 最小键
│ maxKey:          RowKey        │ ← 最大键
└────────────────────────────────┘
```

### LeveledSSTable
```
┌────────────────────────────────┐
│ path:      String              │ ← 文件路径
│ level:     int                 │ ← 所在层级 (0-7)
│ minKey:    RowKey              │ ← 最小键
│ maxKey:    RowKey              │ ← 最大键
│ size:      long                │ ← 文件大小
│ rowCount:  long                │ ← 行数
└────────────────────────────────┘
```

## 性能优化点

### 读优化
1. **Bloom Filter**: 快速判断 key 是否存在 (误判率 1%)
2. **Index Block**: 二分查找定位数据块
3. **Cache**: 可以添加 Block Cache 缓存热点数据

### 写优化
1. **WAL 批量写入**: 减少 fsync 次数
2. **异步 Flush**: 后台线程执行
3. **并发写入**: 多个 MemTable 支持

### Compaction 优化
1. **增量合并**: 避免一次处理过多文件
2. **并行执行**: 不同层级可并发
3. **范围过滤**: 使用 min/max key 跳过无关文件

## 参考

- [Apache Paimon 官方文档](https://paimon.apache.org/)
- [LevelDB 实现](https://github.com/google/leveldb)
- [RocksDB Wiki](https://github.com/facebook/rocksdb/wiki)
