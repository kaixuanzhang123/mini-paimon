package com.mini.paimon.sql;

import com.alibaba.druid.sql.ast.SQLDataType;
import com.alibaba.druid.sql.ast.SQLExpr;
import com.alibaba.druid.sql.ast.SQLName;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.expr.*;
import com.alibaba.druid.sql.ast.statement.*;
import com.alibaba.druid.sql.parser.SQLParserUtils;
import com.alibaba.druid.sql.parser.SQLStatementParser;
import com.alibaba.druid.util.JdbcConstants;
import com.mini.paimon.catalog.Catalog;
import com.mini.paimon.catalog.Identifier;
import com.mini.paimon.exception.CatalogException;
import com.mini.paimon.index.IndexType;
import com.mini.paimon.metadata.DataType;
import com.mini.paimon.metadata.Field;
import com.mini.paimon.metadata.Row;
import com.mini.paimon.metadata.RowKey;
import com.mini.paimon.metadata.Schema;
import com.mini.paimon.partition.PartitionSpec;
import com.mini.paimon.snapshot.Snapshot;
import com.mini.paimon.table.*;
import com.mini.paimon.utils.PathFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

/**
 * SQL 解析器
 * 支持 CREATE TABLE、INSERT 和 SELECT 语句的解析
 * 使用 Druid SQL Parser 实现标准 SQL 解析
 * 
 * 索引配置通过 SQL 注释传递，格式：
 * -- @INDEX: file.index.all=bloom-filter,min-max
 * -- @INDEX: file.index.fieldName.bloom-filter=true
 */
public class SQLParser {
    private static final Logger logger = LoggerFactory.getLogger(SQLParser.class);
    
    private final Catalog catalog;
    private final PathFactory pathFactory;
    
    public SQLParser(Catalog catalog, PathFactory pathFactory) {
        this.catalog = catalog;
        this.pathFactory = pathFactory;
    }
    
    /**
     * 解析并执行 SQL 语句
     * 支持 TBLPROPERTIES 语法（自定义解析）
     * 
     * @param sql SQL 语句
     * @throws IOException 解析或执行错误
     */
    public void executeSQL(String sql) throws IOException {
        // 检查是否包含 TBLPROPERTIES
        if (sql.toUpperCase().contains("TBLPROPERTIES")) {
            executeCreateTableWithTblProperties(sql);
            return;
        }
        
        // 先提取索引配置注释（兼容旧方式）
        Map<String, String> indexConfigFromComment = extractIndexConfigFromComments(sql);
        
        SQLStatementParser parser = SQLParserUtils.createSQLStatementParser(sql, JdbcConstants.MYSQL);
        List<SQLStatement> statements = parser.parseStatementList();
        
        if (statements.isEmpty()) {
            throw new IllegalArgumentException("Empty SQL statement");
        }
        
        SQLStatement statement = statements.get(0);
        
        if (statement instanceof SQLCreateTableStatement) {
            executeCreateTable((SQLCreateTableStatement) statement, indexConfigFromComment);
        } else if (statement instanceof SQLInsertStatement) {
            executeInsert((SQLInsertStatement) statement);
        } else if (statement instanceof SQLSelectStatement) {
            executeSelect((SQLSelectStatement) statement);
        } else if (statement instanceof SQLDeleteStatement) {
            executeDelete((SQLDeleteStatement) statement);
        } else if (statement instanceof com.alibaba.druid.sql.ast.statement.SQLDropTableStatement) {
            executeDropTable((com.alibaba.druid.sql.ast.statement.SQLDropTableStatement) statement);
        } else {
            throw new IllegalArgumentException("Unsupported SQL statement: " + statement.getClass().getSimpleName());
        }
    }
    
    /**
     * 从 SQL 注释中提取索引配置
     * 格式：-- @INDEX: key=value
     */
    private Map<String, String> extractIndexConfigFromComments(String sql) {
        Map<String, String> config = new HashMap<>();
        String[] lines = sql.split("\n");
        
        for (String line : lines) {
            String trimmed = line.trim();
            if (trimmed.startsWith("--") && trimmed.contains("@INDEX:")) {
                String indexPart = trimmed.substring(trimmed.indexOf("@INDEX:") + 7).trim();
                String[] kv = indexPart.split("=", 2);
                if (kv.length == 2) {
                    config.put(kv[0].trim(), kv[1].trim());
                }
            }
        }
        
        return config;
    }
    
    /**
     * 解析并执行 CREATE TABLE 语句
     * 支持格式：CREATE TABLE table_name (...) 或 CREATE TABLE database.table_name (...)
     * 
     * @param stmt CREATE TABLE 语句
     * @param indexConfigFromComment 从注释中提取的索引配置
     * @throws IOException 解析或执行错误
     */
    private void executeCreateTable(SQLCreateTableStatement stmt, Map<String, String> indexConfigFromComment) throws IOException {
        String fullTableName = stmt.getTableSource().toString();
        
        // 解析表名，支持 database.table 格式
        Identifier identifier = parseTableIdentifier(fullTableName);
        String database = identifier.getDatabase();
        String tableName = identifier.getTable();
        
        List<Field> fields = new ArrayList<>();
        List<String> primaryKeys = new ArrayList<>();
        List<String> partitionKeys = new ArrayList<>();
        
        // 解析列定义
        for (SQLTableElement element : stmt.getTableElementList()) {
            if (element instanceof SQLColumnDefinition) {
                SQLColumnDefinition columnDef = (SQLColumnDefinition) element;
                String columnName = columnDef.getName().getSimpleName();
                
                // 获取数据类型
                SQLDataType sqlDataType = columnDef.getDataType();
                DataType dataType = convertDataType(sqlDataType);
                
                // 检查是否为可空字段
                boolean nullable = true;
                for (SQLColumnConstraint constraint : columnDef.getConstraints()) {
                    if (constraint instanceof SQLNotNullConstraint) {
                        nullable = false;
                        break;
                    }
                }
                
                fields.add(new Field(columnName, dataType, nullable));
            }
        }
        
        // 检查是否有在列定义中指定的主键约束（向后兼容）
        for (SQLTableElement element : stmt.getTableElementList()) {
            if (element instanceof SQLColumnDefinition) {
                SQLColumnDefinition columnDef = (SQLColumnDefinition) element;
                for (SQLColumnConstraint constraint : columnDef.getConstraints()) {
                    if ("PRIMARY KEY".equalsIgnoreCase(constraint.getClass().getSimpleName())) {
                        primaryKeys.add(columnDef.getName().getSimpleName());
                        break;
                    }
                }
            }
        }
        
        // 解析 PARTITIONED BY 子句
        Object partitioning = stmt.getPartitioning();
        if (partitioning != null) {
            try {
                // 使用反射获取 columns
                java.lang.reflect.Method getColumnsMethod = partitioning.getClass().getMethod("getColumns");
                @SuppressWarnings("unchecked")
                List<SQLExpr> columns = (List<SQLExpr>) getColumnsMethod.invoke(partitioning);
                for (SQLExpr column : columns) {
                    if (column instanceof SQLIdentifierExpr) {
                        partitionKeys.add(((SQLIdentifierExpr) column).getName());
                    } else if (column instanceof SQLName) {
                        partitionKeys.add(((SQLName) column).getSimpleName());
                    }
                }
            } catch (Exception e) {
                // 如果解析失败，忽略分区
                logger.warn("Failed to parse partition keys: {}", e.getMessage());
            }
        }
        
        // 如果没有显式指定主键，但有 NOT NULL 字段，可以将其作为主键（简化处理）
        if (primaryKeys.isEmpty()) {
            for (Field field : fields) {
                if (!field.isNullable()) {
                    primaryKeys.add(field.getName());
                    break;
                }
            }
        }
        
        // 解析表属性（TBLPROPERTIES）或注释中的索引配置
        Map<String, List<IndexType>> indexConfig = parseIndexConfig(stmt, fields, indexConfigFromComment);
        
        // 创建 Schema（不指定 schemaId，由 SchemaManager 自动生成）
        Schema schema = new Schema(-1, fields, primaryKeys, partitionKeys);
        
        // 创建表（传入索引配置）
        catalog.createTableWithIndex(identifier, schema, indexConfig, true);
        
        System.out.println("Table '" + identifier.getFullName() + "' created successfully.");
        if (!partitionKeys.isEmpty()) {
            System.out.println("Partition keys: " + partitionKeys);
        }
        if (!indexConfig.isEmpty()) {
            System.out.println("Index configuration: " + formatIndexConfig(indexConfig));
        }
    }
    
    /**
     * 解析表标识符
     * 支持格式：table_name（使用默认数据库） 或 database.table_name
     * 
     * @param fullTableName 完整表名
     * @return 表标识符
     */
    private Identifier parseTableIdentifier(String fullTableName) {
        if (fullTableName.contains(".")) {
            // 使用 Identifier.fromString 解析 database.table 格式
            return Identifier.fromString(fullTableName);
        } else {
            // 没有指定数据库，使用默认数据库
            return new Identifier(catalog.getDefaultDatabase(), fullTableName);
        }
    }
    
    /**
     * 解析并执行 DROP TABLE 语句
     * 删除整个表目录，包括所有数据和元数据
     * 
     * @param stmt DROP TABLE 语句
     * @throws IOException 解析或执行错误
     */
    private void executeDropTable(com.alibaba.druid.sql.ast.statement.SQLDropTableStatement stmt) throws IOException {
        // 获取表名：尝试多种方法获取完整表名
        com.alibaba.druid.sql.ast.statement.SQLExprTableSource tableSource = stmt.getTableSources().get(0);
        String fullTableName = tableSource.toString(); // 使用 toString() 获取完整表名（包括数据库名）
        
        // 解析表标识符
        Identifier identifier = parseTableIdentifier(fullTableName);
        
        // 删除表（会删除整个表目录）
        try {
            catalog.dropTable(identifier, stmt.isIfExists());
            System.out.println("Table '" + identifier.getFullName() + "' dropped successfully.");
        } catch (CatalogException e) {
            if (!stmt.isIfExists()) {
                throw new IOException("Failed to drop table: " + e.getMessage(), e);
            }
            System.out.println("Table '" + identifier.getFullName() + "' does not exist (ignored).");
        }
    }
    
    /**
     * 解析并执行 INSERT 语句
     * 
     * @param stmt INSERT 语句
     * @throws IOException 解析或执行错误
     */
    private void executeInsert(SQLInsertStatement stmt) throws IOException {
        String fullTableName = stmt.getTableName().toString();
        
        // 解析表标识符
        Identifier identifier = parseTableIdentifier(fullTableName);
        
        // 获取表的 Schema
        Schema schema = catalog.getTableSchema(identifier);
        
        if (schema == null) {
            throw new IOException("Table '" + identifier.getFullName() + "' not found");
        }
        
        List<Field> fields = schema.getFields();
        
        // 处理列名（如果指定了）
        List<String> columnNames = new ArrayList<>();
        if (stmt.getColumns().isEmpty()) {
            // 使用所有列
            for (Field field : fields) {
                columnNames.add(field.getName());
            }
        } else {
            // 使用指定列
            for (SQLExpr columnExpr : stmt.getColumns()) {
                if (columnExpr instanceof SQLIdentifierExpr) {
                    columnNames.add(((SQLIdentifierExpr) columnExpr).getName());
                } else {
                    throw new IllegalArgumentException("Unsupported column expression: " + columnExpr);
                }
            }
        }
        
        // 处理值
        List<SQLInsertStatement.ValuesClause> valuesList = stmt.getValuesList();
        if (valuesList.isEmpty()) {
            throw new IllegalArgumentException("No values specified in INSERT statement");
        }
        
        // 只处理第一行数据（简化处理）
        SQLInsertStatement.ValuesClause valuesClause = valuesList.get(0);
        List<SQLExpr> valueExprs = valuesClause.getValues();
        
        // 验证列数和值数是否匹配
        if (valueExprs.size() != columnNames.size()) {
            throw new IllegalArgumentException(
                "Value count doesn't match column count. Expected: " + columnNames.size() + ", Actual: " + valueExprs.size());
        }
        
        // 构造数据行
        Object[] rowValues = new Object[fields.size()];
        
        for (int i = 0; i < fields.size(); i++) {
            Field field = fields.get(i);
            int columnIndex = columnNames.indexOf(field.getName());
            if (columnIndex >= 0) {
                SQLExpr valueExpr = valueExprs.get(columnIndex);
                rowValues[i] = convertValue(valueExpr, field.getType());
            } else {
                rowValues[i] = null;
            }
        }
        
        com.mini.paimon.table.Table table = catalog.getTable(identifier);
        try (TableWrite tableWrite = table.newWrite()) {
            Row row = new Row(rowValues);
            tableWrite.write(row);
            TableWrite.TableCommitMessage commitMessage = tableWrite.prepareCommit();
            
            TableCommit tableCommit = table.newCommit();
            tableCommit.commit(commitMessage, Snapshot.CommitKind.APPEND);
            
            System.out.println("Data inserted into table '" + identifier.getFullName() + "' successfully.");
        } catch (Exception e) {
            throw new IOException("Failed to insert data: " + e.getMessage(), e);
        }
    }
    
    /**
     * 解析并执行 SELECT 语句
     * 支持字段投影和 WHERE 条件过滤
     * 
     * @param stmt SELECT 语句
     * @throws IOException 解析或执行错误
     */
    private void executeSelect(SQLSelectStatement stmt) throws IOException {
        SQLSelectQuery query = stmt.getSelect().getQuery();
        
        if (!(query instanceof SQLSelectQueryBlock)) {
            throw new IllegalArgumentException("Only simple SELECT queries are supported");
        }
        
        SQLSelectQueryBlock queryBlock = (SQLSelectQueryBlock) query;
        
        // 1. 获取表名
        if (!(queryBlock.getFrom() instanceof SQLExprTableSource)) {
            throw new IllegalArgumentException("Only single table SELECT is supported");
        }
        
        SQLExprTableSource tableSource = (SQLExprTableSource) queryBlock.getFrom();
        String fullTableName = tableSource.getExpr().toString();
        
        // 2. 解析表标识符并获取表的 Schema
        Identifier identifier = parseTableIdentifier(fullTableName);
        Schema schema = catalog.getTableSchema(identifier);
        
        if (schema == null) {
            throw new IOException("Table '" + identifier.getFullName() + "' not found");
        }
        
        // 3. 解析投影（SELECT 字段列表）
        Projection projection = parseProjection(queryBlock, schema);
        
        // 4. 解析 WHERE 条件
        Predicate predicate = parseWhere(queryBlock, schema);
        
        // 5. 执行查询：DataTableScan -> DataTableRead
        DataTableScan tableScan = new DataTableScan(pathFactory, identifier.getDatabase(), identifier.getTable(), schema);
        DataTableScan.Plan plan = tableScan.plan();
        
        // 修复：正确初始化DataTableRead，传递所有必需的参数
        DataTableRead tableRead = new DataTableRead(schema, pathFactory, identifier.getDatabase(), identifier.getTable());
        if (projection != null) {
            tableRead.withProjection(projection);
        }
        if (predicate != null) {
            tableRead.withFilter(predicate);
        }
        
        List<Row> rows = tableRead.read(plan);
        
        // 6. 打印结果
        Schema resultSchema = projection != null ? projection.projectSchema(schema) : schema;
        printResults(resultSchema, rows);
    }
    
    /**
     * 打印查询结果
     * 
     * @param schema 表的Schema
     * @param rows 查询到的数据行
     */
    private void printResults(Schema schema, List<Row> rows) {
        // 打印列标题
        List<Field> fields = schema.getFields();
        for (int i = 0; i < fields.size(); i++) {
            if (i > 0) System.out.print("\t");
            System.out.print(fields.get(i).getName());
        }
        System.out.println();
        
        // 打印分隔线
        for (int i = 0; i < fields.size(); i++) {
            if (i > 0) System.out.print("\t");
            System.out.print("--------");
        }
        System.out.println();
        
        // 打印数据行
        for (Row row : rows) {
            Object[] values = row.getValues();
            for (int i = 0; i < values.length; i++) {
                if (i > 0) System.out.print("\t");
                System.out.print(values[i] != null ? values[i].toString() : "NULL");
            }
            System.out.println();
        }
        
        System.out.println(rows.size() + " row(s) returned");
    }
    
    /**
     * 转换 SQL 数据类型为内部数据类型
     */
    private DataType convertDataType(SQLDataType sqlDataType) {
        String typeName = sqlDataType.getName().toUpperCase();
        
        switch (typeName) {
            case "INT":
            case "INTEGER":
                return DataType.INT;
            case "BIGINT":
            case "LONG":
                return DataType.LONG;
            case "VARCHAR":
            case "CHAR":
            case "TEXT":
            case "STRING":
                return DataType.STRING;
            case "BOOLEAN":
            case "BOOL":
                return DataType.BOOLEAN;
            case "DOUBLE":
            case "FLOAT":
                return DataType.DOUBLE;
            default:
                throw new IllegalArgumentException("Unsupported data type: " + typeName);
        }
    }
    
    /**
     * 转换 SQL 表达式值为指定类型
     */
    private Object convertValue(SQLExpr valueExpr, DataType dataType) {
        if (valueExpr instanceof SQLNullExpr) {
            return null;
        }
        
        String valueStr;
        if (valueExpr instanceof SQLCharExpr) {
            valueStr = ((SQLCharExpr) valueExpr).getText();
        } else if (valueExpr instanceof SQLIntegerExpr) {
            valueStr = String.valueOf(((SQLIntegerExpr) valueExpr).getNumber());
        } else if (valueExpr instanceof SQLBooleanExpr) {
            valueStr = String.valueOf(((SQLBooleanExpr) valueExpr).getValue());
        } else if (valueExpr instanceof SQLNumberExpr) {
            valueStr = String.valueOf(((SQLNumberExpr) valueExpr).getNumber());
        } else {
            valueStr = valueExpr.toString();
            // 移除可能的引号
            if (valueStr.startsWith("'") && valueStr.endsWith("'")) {
                valueStr = valueStr.substring(1, valueStr.length() - 1);
            } else if (valueStr.startsWith("\"") && valueStr.endsWith("\"")) {
                valueStr = valueStr.substring(1, valueStr.length() - 1);
            }
        }
        
        switch (dataType) {
            case INT:
                return Integer.parseInt(valueStr);
            case LONG:
                return Long.parseLong(valueStr);
            case STRING:
                return valueStr;
            case BOOLEAN:
                return Boolean.parseBoolean(valueStr);
            case DOUBLE:
                return Double.parseDouble(valueStr);
            default:
                throw new IllegalArgumentException("Unsupported data type: " + dataType);
        }
    }
    
    /**
     * 解析投影（SELECT 字段列表）
     */
    private Projection parseProjection(SQLSelectQueryBlock queryBlock, Schema schema) {
        List<SQLSelectItem> selectItems = queryBlock.getSelectList();
        
        // 检查是否是 SELECT *
        if (selectItems.size() == 1 && selectItems.get(0).getExpr() instanceof SQLAllColumnExpr) {
            return Projection.all();
        }
        
        // 解析具体字段
        List<String> fields = new ArrayList<>();
        for (SQLSelectItem item : selectItems) {
            SQLExpr expr = item.getExpr();
            
            if (expr instanceof SQLIdentifierExpr) {
                fields.add(((SQLIdentifierExpr) expr).getName());
            } else if (expr instanceof SQLPropertyExpr) {
                // 支持 table.column 形式
                fields.add(((SQLPropertyExpr) expr).getName());
            } else {
                throw new IllegalArgumentException("Unsupported SELECT expression: " + expr);
            }
        }
        
        return Projection.of(fields);
    }
    
    /**
     * 解析 WHERE 条件
     */
    private Predicate parseWhere(SQLSelectQueryBlock queryBlock, Schema schema) {
        SQLExpr whereExpr = queryBlock.getWhere();
        if (whereExpr == null) {
            return null;
        }
        
        return parseExpression(whereExpr, schema);
    }
    
    /**
     * 解析表达式为谓词
     */
    private Predicate parseExpression(SQLExpr expr, Schema schema) {
        if (expr instanceof SQLBinaryOpExpr) {
            SQLBinaryOpExpr binaryExpr = (SQLBinaryOpExpr) expr;
            
            // 逻辑运算符
            if (binaryExpr.getOperator() == SQLBinaryOperator.BooleanAnd) {
                Predicate left = parseExpression(binaryExpr.getLeft(), schema);
                Predicate right = parseExpression(binaryExpr.getRight(), schema);
                return left.and(right);
            } else if (binaryExpr.getOperator() == SQLBinaryOperator.BooleanOr) {
                Predicate left = parseExpression(binaryExpr.getLeft(), schema);
                Predicate right = parseExpression(binaryExpr.getRight(), schema);
                return left.or(right);
            }
            
            // 比较运算符
            String fieldName = extractFieldName(binaryExpr.getLeft());
            Object value = extractValue(binaryExpr.getRight(), schema, fieldName);
            
            switch (binaryExpr.getOperator()) {
                case Equality:
                    return Predicate.equal(fieldName, value);
                case NotEqual:
                case LessThanOrGreater:
                    return Predicate.notEqual(fieldName, value);
                case GreaterThan:
                    return Predicate.greaterThan(fieldName, value);
                case GreaterThanOrEqual:
                    return Predicate.greaterOrEqual(fieldName, value);
                case LessThan:
                    return Predicate.lessThan(fieldName, value);
                case LessThanOrEqual:
                    return Predicate.lessOrEqual(fieldName, value);
                default:
                    throw new IllegalArgumentException("Unsupported operator: " + binaryExpr.getOperator());
            }
        }
        
        throw new IllegalArgumentException("Unsupported WHERE expression: " + expr);
    }
    
    /**
     * 提取字段名
     */
    private String extractFieldName(SQLExpr expr) {
        if (expr instanceof SQLIdentifierExpr) {
            return ((SQLIdentifierExpr) expr).getName();
        } else if (expr instanceof SQLPropertyExpr) {
            return ((SQLPropertyExpr) expr).getName();
        }
        throw new IllegalArgumentException("Unsupported field expression: " + expr);
    }
    
    /**
     * 提取值
     */
    private Object extractValue(SQLExpr expr, Schema schema, String fieldName) {
        // 查找字段类型
        DataType dataType = null;
        for (Field field : schema.getFields()) {
            if (field.getName().equals(fieldName)) {
                dataType = field.getType();
                break;
            }
        }
        
        if (dataType == null) {
            throw new IllegalArgumentException("Field not found: " + fieldName);
        }
        
        return convertValue(expr, dataType);
    }
    
    /**
     * 解析并执行 DELETE 语句
     * 支持 DELETE FROM table WHERE condition
     * 参考 Paimon 实现：
     * - 按分区删除：物理删除分区目录
     * - 按主键删除：读取数据、过滤后重写
     * - 无 WHERE 子句：删除所有数据（对于分区表，删除所有分区）
     * 
     * @param stmt DELETE 语句
     * @throws IOException 解析或执行错误
     */
    private void executeDelete(SQLDeleteStatement stmt) throws IOException {
        String fullTableName = stmt.getTableName().toString();
        
        // 解析表标识符
        Identifier identifier = parseTableIdentifier(fullTableName);
        
        // 获取表的 Schema
        Schema schema = catalog.getTableSchema(identifier);
        
        if (schema == null) {
            throw new IOException("Table '" + identifier.getFullName() + "' not found");
        }
        
        // 获取表
        com.mini.paimon.table.Table table = catalog.getTable(identifier);
        
        // 解析 WHERE 条件
        SQLExpr whereExpr = stmt.getWhere();
        
        // 如果没有 WHERE 子句，删除所有数据
        if (whereExpr == null) {
            deleteAllData(table, schema);
            return;
        }
        
        // 如果是简单的等值条件 (WHERE field = value)
        if (whereExpr instanceof SQLBinaryOpExpr) {
            SQLBinaryOpExpr binaryExpr = (SQLBinaryOpExpr) whereExpr;
            if (binaryExpr.getOperator() == SQLBinaryOperator.Equality) {
                String fieldName = extractFieldName(binaryExpr.getLeft());
                Object value = extractValue(binaryExpr.getRight(), schema, fieldName);
                
                // 如果是分区字段，物理删除分区
                if (schema.getPartitionKeys().contains(fieldName)) {
                    deletePartition(table, fieldName, value);
                    System.out.println("Partition deleted: " + fieldName + "=" + value);
                } else {
                    // 非分区字段，使用 OVERWRITE 重写数据（删除匹配的行）
                    deleteByCondition(table, schema, fieldName, value);
                    System.out.println("Deleted rows where " + fieldName + " = " + value);
                }
            } else {
                throw new IllegalArgumentException(
                    "Only equality condition is supported in DELETE statement");
            }
        } else {
            throw new IllegalArgumentException(
                "Unsupported WHERE expression in DELETE: " + whereExpr);
        }
    }
    
    /**
     * 删除分区
     * 参考 Paimon 实现，直接删除分区目录
     */
    private void deletePartition(com.mini.paimon.table.Table table, 
                                 String partitionKey, Object value) throws IOException {
        Map<String, String> partitionValues = new LinkedHashMap<>();
        partitionValues.put(partitionKey, value.toString());
        PartitionSpec partitionSpec = new PartitionSpec(partitionValues);
        
        // 1. 首先读取当前 Snapshot，获取该分区的所有文件
        List<com.mini.paimon.manifest.ManifestEntry> deleteEntries = new ArrayList<>();
        
        if (com.mini.paimon.snapshot.Snapshot.hasLatestSnapshot(pathFactory, 
                table.identifier().getDatabase(), table.identifier().getTable())) {
            try {
                com.mini.paimon.snapshot.Snapshot snapshot = com.mini.paimon.snapshot.Snapshot.loadLatest(
                    pathFactory, table.identifier().getDatabase(), table.identifier().getTable());
                
                com.mini.paimon.manifest.ManifestList manifestList = com.mini.paimon.manifest.ManifestList.load(
                    pathFactory, table.identifier().getDatabase(), 
                    table.identifier().getTable(), snapshot.getId());
                
                // 遍历所有 manifest files，查找属于该分区的文件
                String partitionPath = partitionSpec.toPath();
                for (com.mini.paimon.manifest.ManifestFileMeta manifestMeta : manifestList.getManifestFiles()) {
                    com.mini.paimon.manifest.ManifestFile manifestFile = com.mini.paimon.manifest.ManifestFile.load(
                        pathFactory, table.identifier().getDatabase(), 
                        table.identifier().getTable(), 
                        manifestMeta.getFileName().substring("manifest-".length()));
                    
                    for (com.mini.paimon.manifest.ManifestEntry entry : manifestFile.getEntries()) {
                        if (entry.getKind() == com.mini.paimon.manifest.ManifestEntry.FileKind.ADD) {
                            // 检查文件是否属于该分区
                            String fileName = entry.getFile().getFileName();
                            if (fileName.startsWith(partitionPath + "/")) {
                                // 创建 DELETE 条目
                                com.mini.paimon.manifest.ManifestEntry deleteEntry = 
                                    com.mini.paimon.manifest.ManifestEntry.deleteFile(
                                        fileName,
                                        entry.getFile().getFileSize(),
                                        entry.getFile().getSchemaId(),
                                        entry.getMinKey(),
                                        entry.getMaxKey(),
                                        entry.getFile().getRowCount(),
                                        entry.getFile().getLevel()
                                    );
                                deleteEntries.add(deleteEntry);
                            }
                        }
                    }
                }
            } catch (IOException e) {
                logger.warn("Failed to load snapshot for partition deletion", e);
            }
        }
        
        // 2. 物理删除分区目录
        table.partitionManager().dropPartition(partitionSpec);
        
        // 3. 创建新快照记录分区删除（使用 APPEND 模式 + DELETE 条目）
        if (!deleteEntries.isEmpty()) {
            // 直接创建 Snapshot，包含 DELETE 条目
            com.mini.paimon.snapshot.SnapshotManager snapshotManager = 
                new com.mini.paimon.snapshot.SnapshotManager(
                    pathFactory, table.identifier().getDatabase(), table.identifier().getTable());
            
            Schema schema = table.schema();
            com.mini.paimon.snapshot.Snapshot snapshot = snapshotManager.createSnapshot(
                schema.getSchemaId(), deleteEntries, 
                com.mini.paimon.snapshot.Snapshot.CommitKind.APPEND);
            
            // 关键：通过 Catalog 提交 Snapshot，更新 latest snapshot 指针
            catalog.commitSnapshot(table.identifier(), snapshot);
        }
    }
    
    /**
     * 删除所有数据
     * 对于分区表：删除所有分区目录
     * 对于非分区表：重写为空表
     */
    private void deleteAllData(com.mini.paimon.table.Table table, Schema schema) throws IOException {
        if (schema.getPartitionKeys().isEmpty()) {
            // 非分区表：重写为空表
            try (TableWrite writer = table.newWrite()) {
                // 不写入任何数据
                TableWrite.TableCommitMessage commitMsg = writer.prepareCommit();
                TableCommit commit = table.newCommit();
                commit.commit(commitMsg, Snapshot.CommitKind.OVERWRITE);
            }
            System.out.println("All data deleted from table");
        } else {
            // 分区表：删除所有分区
            List<PartitionSpec> partitions = table.partitionManager().listPartitions();
            
            if (partitions.isEmpty()) {
                System.out.println("No partitions to delete");
                return;
            }
            
            // 物理删除分区目录
            for (PartitionSpec partition : partitions) {
                table.partitionManager().dropPartition(partition);
            }
            
            // 创建 OVERWRITE 快照（空的数据文件列表）
            try (TableWrite writer = table.newWrite()) {
                // 不写入任何数据，prepareCommit 会收集现有的文件（应该为空）
                TableWrite.TableCommitMessage commitMsg = writer.prepareCommit();
                TableCommit commit = table.newCommit();
                commit.commit(commitMsg, Snapshot.CommitKind.OVERWRITE);
            }
            
            System.out.println("Deleted all " + partitions.size() + " partitions");
        }
    }
    
    /**
     * 按条件删除数据
     * 通过读取所有数据、过滤后重写实现
     */
    private void deleteByCondition(com.mini.paimon.table.Table table, 
                                   Schema schema, String fieldName, Object value) throws IOException {
        // 1. 读取所有现有数据
        TableScan scan = table.newScan().withLatestSnapshot();
        TableScan.Plan plan = scan.plan();
        TableRead reader = table.newRead();
        List<Row> allRows = reader.read(plan);
        
        // 2. 过滤掉需要删除的行
        List<Row> remainingRows = new ArrayList<>();
        int fieldIndex = schema.getFieldIndex(fieldName);
        
        if (fieldIndex < 0) {
            throw new IllegalArgumentException("Field not found: " + fieldName);
        }
        
        for (Row row : allRows) {
            Object rowValue = row.getValue(fieldIndex);
            // 保留不匹配的行
            if (!value.equals(rowValue)) {
                remainingRows.add(row);
            }
        }
        
        int deletedCount = allRows.size() - remainingRows.size();
        
        if (deletedCount == 0) {
            System.out.println("No rows matched the condition");
            return;
        }
        
        // 3. OVERWRITE 模式：清空 WAL 文件，避免新创建的 LSMTree 从 WAL 恢复旧数据
        cleanupWALFiles(table);
        
        // 4. 重写数据（OVERWRITE）
        try (TableWrite writer = table.newWrite()) {
            for (Row row : remainingRows) {
                writer.write(row);
            }
            
            TableWrite.TableCommitMessage commitMsg = writer.prepareCommit();
            
            TableCommit commit = table.newCommit();
            commit.commit(commitMsg, Snapshot.CommitKind.OVERWRITE);
        }
        
        System.out.println(deletedCount + " row(s) deleted");
    }
    
    /**
     * 清空 WAL 文件
     * 在 OVERWRITE 提交前调用，避免 WAL 恢复导致数据重复
     */
    private void cleanupWALFiles(com.mini.paimon.table.Table table) throws IOException {
        try {
            java.nio.file.Path walDir = pathFactory.getWalDir(table.identifier().getDatabase(), 
                                               table.identifier().getTable());
            if (java.nio.file.Files.exists(walDir)) {
                try (java.util.stream.Stream<java.nio.file.Path> stream = java.nio.file.Files.walk(walDir)) {
                    stream.filter(path -> path.toString().endsWith(".log"))
                          .forEach(path -> {
                              try {
                                  java.nio.file.Files.deleteIfExists(path);
                              } catch (IOException e) {
                                  logger.warn("Failed to delete WAL file: " + path, e);
                              }
                          });
                }
            }
        } catch (IOException e) {
            logger.warn("Failed to cleanup WAL files", e);
        }
    }
    
    /**
     * 解析索引配置
     * 从 CREATE TABLE 语句的 TBLPROPERTIES 或 SQL 注释中解析索引配置
     * 
     * 支持的语法：
     * 1. 'file.index.all' = 'bloom-filter,min-max'  -- 为所有字段创建索引
     * 2. 'file.index.fieldName.bloom-filter' = 'true'  -- 为指定字段创建 bloom-filter 索引
     * 3. 'file.index.fieldName.min-max' = 'true'  -- 为指定字段创建 min-max 索引
     * 
     * 通过注释传递（Druid 不支持 TBLPROPERTIES）：
     * -- @INDEX: file.index.all=bloom-filter,min-max
     * -- @INDEX: file.index.name.bloom-filter=true
     */
    private Map<String, List<IndexType>> parseIndexConfig(SQLCreateTableStatement stmt, List<Field> fields, 
                                                          Map<String, String> indexConfigFromComment) {
        Map<String, List<IndexType>> indexConfig = new HashMap<>();
        
        // 优先从注释中获取配置
        Map<String, String> properties = new HashMap<>(indexConfigFromComment);
        
        // 尝试从 TableOptions 中获取（虽然 Druid 不支持 TBLPROPERTIES，但保留兼容性）
        List<SQLAssignItem> tableOptions = stmt.getTableOptions();
        if (tableOptions != null && !tableOptions.isEmpty()) {
            for (SQLAssignItem option : tableOptions) {
                String key = option.getTarget().toString().replace("'", "").replace("`", "");
                String value = option.getValue().toString().replace("'", "").replace("`", "");
                properties.put(key, value);
            }
        }
        
        // 解析全局索引配置
        String allIndexTypes = properties.get("file.index.all");
        if (allIndexTypes != null && !allIndexTypes.trim().isEmpty()) {
            List<IndexType> types = parseIndexTypes(allIndexTypes);
            if (!types.isEmpty()) {
                // 为所有字段创建索引
                for (Field field : fields) {
                    indexConfig.put(field.getName(), new ArrayList<>(types));
                }
            }
        }
        
        // 解析字段级索引配置
        for (Map.Entry<String, String> entry : properties.entrySet()) {
            String key = entry.getKey();
            String value = entry.getValue();
            
            // 匹配 file.index.<fieldName>.<indexType>
            if (key.startsWith("file.index.") && !key.equals("file.index.all")) {
                String[] parts = key.split("\\.");
                if (parts.length == 4 && "true".equalsIgnoreCase(value)) {
                    String fieldName = parts[2];
                    String indexTypeName = parts[3];
                    
                    // 验证字段是否存在
                    boolean fieldExists = fields.stream()
                        .anyMatch(f -> f.getName().equals(fieldName));
                    
                    if (fieldExists) {
                        try {
                            IndexType indexType = parseIndexType(indexTypeName);
                            indexConfig.computeIfAbsent(fieldName, k -> new ArrayList<>())
                                      .add(indexType);
                        } catch (IllegalArgumentException e) {
                            logger.warn("Unknown index type: {}", indexTypeName);
                        }
                    } else {
                        logger.warn("Field '{}' not found in schema, skipping index config", fieldName);
                    }
                }
            }
        }
        
        return indexConfig;
    }
    
    /**
     * 解析索引类型列表（从逗号分隔的字符串）
     */
    private List<IndexType> parseIndexTypes(String indexTypesStr) {
        List<IndexType> types = new ArrayList<>();
        String[] parts = indexTypesStr.split(",");
        for (String part : parts) {
            String trimmed = part.trim();
            if (!trimmed.isEmpty()) {
                try {
                    types.add(parseIndexType(trimmed));
                } catch (IllegalArgumentException e) {
                    logger.warn("Unknown index type: {}", trimmed);
                }
            }
        }
        return types;
    }
    
    /**
     * 解析单个索引类型
     */
    private IndexType parseIndexType(String typeName) {
        switch (typeName.toLowerCase()) {
            case "bloom-filter":
            case "bloom_filter":
                return IndexType.BLOOM_FILTER;
            case "min-max":
            case "min_max":
            case "minmax":
                return IndexType.MIN_MAX;
            default:
                throw new IllegalArgumentException("Unknown index type: " + typeName);
        }
    }
    
    /**
     * 格式化索引配置输出
     */
    private String formatIndexConfig(Map<String, List<IndexType>> indexConfig) {
        if (indexConfig.isEmpty()) {
            return "none";
        }
        
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<String, List<IndexType>> entry : indexConfig.entrySet()) {
            if (sb.length() > 0) {
                sb.append(", ");
            }
            sb.append(entry.getKey()).append("[");
            for (int i = 0; i < entry.getValue().size(); i++) {
                if (i > 0) sb.append(",");
                sb.append(entry.getValue().get(i).getName());
            }
            sb.append("]");
        }
        return sb.toString();
    }
}